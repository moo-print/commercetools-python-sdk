# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType

__all__ = [
    "ApplicationDeactivated",
    "ApplicationNotFound",
    "BadInputData",
    "CartEmptiedDuringCheckout",
    "CartEmpty",
    "CartNotFound",
    "CartWithExistingPayment",
    "CheckoutCancelled",
    "CheckoutCompleted",
    "CheckoutLoaded",
    "CheckoutStarted",
    "DeprecatedFields",
    "ExternalTermsAndConditionsPending",
    "InitError",
    "InitTimeout",
    "InvalidMode",
    "InvalidToken",
    "Message",
    "NoPaymentMethods",
    "NoShippingMethods",
    "OrderCreated",
    "OrderCreationError",
    "PaymentCancelled",
    "PaymentConnectorError",
    "PaymentFailed",
    "PaymentMethodLoaded",
    "PaymentMethodLoading",
    "PaymentMethodLoadingError",
    "PaymentMethodSelected",
    "PaymentMethodSelectionConfirmation",
    "PaymentMethodSelectionConfirmationFailed",
    "PaymentMethodsReceived",
    "PaymentStarted",
    "PaymentValidationFailed",
    "PaymentValidationPassed",
    "PaymentValidationStarted",
    "PaymentVerificationStarted",
    "PaymentVerificationTimeout",
    "ProjectIsDeactivated",
    "ResponseMessage",
    "UnavailableLocale",
    "UnsupportedCountry",
]


class Message(_BaseType):
    #: The Message code for the event.
    code: str
    #: The severity level of the event. It can be `info`, `warn`, or `error`.
    severity: str
    #: A human-readable description of the event.
    message: str

    def __init__(self, *, code: str, severity: str, message: str):
        self.code = code
        self.severity = severity
        self.message = message

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Message":
        if data["code"] == "checkout_cancelled":
            from ._schemas.responses import CheckoutCancelledSchema

            return CheckoutCancelledSchema().load(data)
        if data["code"] == "checkout_loaded":
            from ._schemas.responses import CheckoutLoadedSchema

            return CheckoutLoadedSchema().load(data)
        if data["code"] == "checkout_started":
            from ._schemas.responses import CheckoutStartedSchema

            return CheckoutStartedSchema().load(data)
        if data["code"] == "init_timeout":
            from ._schemas.responses import InitTimeoutSchema

            return InitTimeoutSchema().load(data)
        if data["code"] == "invalid_mode":
            from ._schemas.responses import InvalidModeSchema

            return InvalidModeSchema().load(data)
        if data["code"] == "invalid_token":
            from ._schemas.responses import InvalidTokenSchema

            return InvalidTokenSchema().load(data)
        if data["code"] == "no_payment_methods":
            from ._schemas.responses import NoPaymentMethodsSchema

            return NoPaymentMethodsSchema().load(data)
        if data["code"] == "payment_failed":
            from ._schemas.responses import PaymentFailedSchema

            return PaymentFailedSchema().load(data)
        if data["code"] == "init_error":
            from ._schemas.responses import InitErrorSchema

            return InitErrorSchema().load(data)
        if data["code"] == "payment_cancelled":
            from ._schemas.responses import PaymentCancelledSchema

            return PaymentCancelledSchema().load(data)
        if data["code"] == "payment_validation_failed":
            from ._schemas.responses import PaymentValidationFailedSchema

            return PaymentValidationFailedSchema().load(data)
        if data["code"] == "payment_validation_passed":
            from ._schemas.responses import PaymentValidationPassedSchema

            return PaymentValidationPassedSchema().load(data)
        if data["code"] == "payment_validation_started":
            from ._schemas.responses import PaymentValidationStartedSchema

            return PaymentValidationStartedSchema().load(data)
        if data["code"] == "payment_verification_started":
            from ._schemas.responses import PaymentVerificationStartedSchema

            return PaymentVerificationStartedSchema().load(data)
        if data["code"] == "payment_verification_timeout":
            from ._schemas.responses import PaymentVerificationTimeoutSchema

            return PaymentVerificationTimeoutSchema().load(data)
        if data["code"] == "external_terms_and_conditions_pending":
            from ._schemas.responses import ExternalTermsAndConditionsPendingSchema

            return ExternalTermsAndConditionsPendingSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import MessageSchema

        return MessageSchema().dump(self)


class ResponseMessage(Message):
    #: Additional data about the event.
    payload: object

    def __init__(self, *, code: str, severity: str, message: str, payload: object):
        self.payload = payload

        super().__init__(code=code, severity=severity, message=message)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ResponseMessage":
        if data["code"] == "application_disabled":
            from ._schemas.responses import ApplicationDeactivatedSchema

            return ApplicationDeactivatedSchema().load(data)
        if data["code"] == "application_not_found":
            from ._schemas.responses import ApplicationNotFoundSchema

            return ApplicationNotFoundSchema().load(data)
        if data["code"] == "cart_emptied_during_checkout":
            from ._schemas.responses import CartEmptiedDuringCheckoutSchema

            return CartEmptiedDuringCheckoutSchema().load(data)
        if data["code"] == "cart_empty":
            from ._schemas.responses import CartEmptySchema

            return CartEmptySchema().load(data)
        if data["code"] == "cart_not_found":
            from ._schemas.responses import CartNotFoundSchema

            return CartNotFoundSchema().load(data)
        if data["code"] == "checkout_completed":
            from ._schemas.responses import CheckoutCompletedSchema

            return CheckoutCompletedSchema().load(data)
        if data["code"] == "invalid_fields":
            from ._schemas.responses import BadInputDataSchema

            return BadInputDataSchema().load(data)
        if data["code"] == "payment_started":
            from ._schemas.responses import PaymentStartedSchema

            return PaymentStartedSchema().load(data)
        if data["code"] == "payment_connector_error":
            from ._schemas.responses import PaymentConnectorErrorSchema

            return PaymentConnectorErrorSchema().load(data)
        if data["code"] == "payment_method_loaded":
            from ._schemas.responses import PaymentMethodLoadedSchema

            return PaymentMethodLoadedSchema().load(data)
        if data["code"] == "payment_method_loading":
            from ._schemas.responses import PaymentMethodLoadingSchema

            return PaymentMethodLoadingSchema().load(data)
        if data["code"] == "payment_method_loading_error":
            from ._schemas.responses import PaymentMethodLoadingErrorSchema

            return PaymentMethodLoadingErrorSchema().load(data)
        if data["code"] == "payment_method_selected":
            from ._schemas.responses import PaymentMethodSelectedSchema

            return PaymentMethodSelectedSchema().load(data)
        if data["code"] == "payment_method_selection_confirmation":
            from ._schemas.responses import PaymentMethodSelectionConfirmationSchema

            return PaymentMethodSelectionConfirmationSchema().load(data)
        if data["code"] == "payment_method_selection_confirmation_failed":
            from ._schemas.responses import (
                PaymentMethodSelectionConfirmationFailedSchema,
            )

            return PaymentMethodSelectionConfirmationFailedSchema().load(data)
        if data["code"] == "payment_methods_received":
            from ._schemas.responses import PaymentMethodsReceivedSchema

            return PaymentMethodsReceivedSchema().load(data)
        if data["code"] == "no_shipping_methods":
            from ._schemas.responses import NoShippingMethodsSchema

            return NoShippingMethodsSchema().load(data)
        if data["code"] == "order_created":
            from ._schemas.responses import OrderCreatedSchema

            return OrderCreatedSchema().load(data)
        if data["code"] == "project_deactivated":
            from ._schemas.responses import ProjectIsDeactivatedSchema

            return ProjectIsDeactivatedSchema().load(data)
        if data["code"] == "unavailable_locale":
            from ._schemas.responses import UnavailableLocaleSchema

            return UnavailableLocaleSchema().load(data)
        if data["code"] == "deprecated_fields":
            from ._schemas.responses import DeprecatedFieldsSchema

            return DeprecatedFieldsSchema().load(data)
        if data["code"] == "order_creation_error":
            from ._schemas.responses import OrderCreationErrorSchema

            return OrderCreationErrorSchema().load(data)
        if data["code"] == "cart_with_exisiting_payment":
            from ._schemas.responses import CartWithExistingPaymentSchema

            return CartWithExistingPaymentSchema().load(data)
        if data["code"] == "unsupported_country":
            from ._schemas.responses import UnsupportedCountrySchema

            return UnsupportedCountrySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import ResponseMessageSchema

        return ResponseMessageSchema().dump(self)


class ApplicationDeactivated(ResponseMessage):
    """Generated when the requested [Application](/payment-connectors-applications#applications) is deactivated. Activate the Application in the Merchant Center to continue."""

    def __init__(self, *, severity: str, message: str, payload: object):

        super().__init__(
            severity=severity,
            message=message,
            payload=payload,
            code="application_disabled",
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ApplicationDeactivated":
        from ._schemas.responses import ApplicationDeactivatedSchema

        return ApplicationDeactivatedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import ApplicationDeactivatedSchema

        return ApplicationDeactivatedSchema().dump(self)


class ApplicationNotFound(ResponseMessage):
    """Generated when the requested [Application](/payment-connectors-applications#applications) is not found. The Application may have been deleted or its configuration is incorrect."""

    def __init__(self, *, severity: str, message: str, payload: object):

        super().__init__(
            severity=severity,
            message=message,
            payload=payload,
            code="application_not_found",
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ApplicationNotFound":
        from ._schemas.responses import ApplicationNotFoundSchema

        return ApplicationNotFoundSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import ApplicationNotFoundSchema

        return ApplicationNotFoundSchema().dump(self)


class CartEmptiedDuringCheckout(ResponseMessage):
    """Generated when the [Cart](/../api/projects/carts) was emptied during the checkout process. It is not possible to recover from this, the customer must restart the checkout process."""

    def __init__(self, *, severity: str, message: str, payload: object):

        super().__init__(
            severity=severity,
            message=message,
            payload=payload,
            code="cart_emptied_during_checkout",
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartEmptiedDuringCheckout":
        from ._schemas.responses import CartEmptiedDuringCheckoutSchema

        return CartEmptiedDuringCheckoutSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import CartEmptiedDuringCheckoutSchema

        return CartEmptiedDuringCheckoutSchema().dump(self)


class CartEmpty(ResponseMessage):
    """Generated when the [Cart](/../api/projects/carts) for the current checkout is empty. The Cart must contain at least one [Line Item](/../api/carts-orders-overview#line-items)."""

    def __init__(self, *, severity: str, message: str, payload: object):

        super().__init__(
            severity=severity, message=message, payload=payload, code="cart_empty"
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartEmpty":
        from ._schemas.responses import CartEmptySchema

        return CartEmptySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import CartEmptySchema

        return CartEmptySchema().dump(self)


class CartNotFound(ResponseMessage):
    """Generated when the [Cart](/../api/projects/carts) is not found. To start the checkout process, a valid Cart with at least one [Line Item](/../api/carts-orders-overview#line-items) is required."""

    def __init__(self, *, severity: str, message: str, payload: object):

        super().__init__(
            severity=severity, message=message, payload=payload, code="cart_not_found"
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartNotFound":
        from ._schemas.responses import CartNotFoundSchema

        return CartNotFoundSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import CartNotFoundSchema

        return CartNotFoundSchema().dump(self)


class CheckoutCancelled(Message):
    """Generated when the customer cancels the checkout process."""

    def __init__(self, *, severity: str, message: str):

        super().__init__(severity=severity, message=message, code="checkout_cancelled")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CheckoutCancelled":
        from ._schemas.responses import CheckoutCancelledSchema

        return CheckoutCancelledSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import CheckoutCancelledSchema

        return CheckoutCancelledSchema().dump(self)


class CheckoutCompleted(ResponseMessage):
    """Generated when the customer completes the checkout process."""

    def __init__(self, *, severity: str, message: str, payload: object):

        super().__init__(
            severity=severity,
            message=message,
            payload=payload,
            code="checkout_completed",
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CheckoutCompleted":
        from ._schemas.responses import CheckoutCompletedSchema

        return CheckoutCompletedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import CheckoutCompletedSchema

        return CheckoutCompletedSchema().dump(self)


class CheckoutLoaded(Message):
    """Generated when Checkout is loaded and waiting for the configuration properties to be passed with the `checkoutFlow` or `paymentFlow` [method](/sdk)."""

    def __init__(self, *, severity: str, message: str):

        super().__init__(severity=severity, message=message, code="checkout_loaded")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CheckoutLoaded":
        from ._schemas.responses import CheckoutLoadedSchema

        return CheckoutLoadedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import CheckoutLoadedSchema

        return CheckoutLoadedSchema().dump(self)


class CheckoutStarted(Message):
    """Generated when the configuration properties are passed successfully with the `checkoutFlow` or `paymentFlow` [method](/sdk) and the checkout process starts."""

    def __init__(self, *, severity: str, message: str):

        super().__init__(severity=severity, message=message, code="checkout_started")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CheckoutStarted":
        from ._schemas.responses import CheckoutStartedSchema

        return CheckoutStartedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import CheckoutStartedSchema

        return CheckoutStartedSchema().dump(self)


class InitTimeout(Message):
    """Generated when Checkout does not receive the configuration properties with the `checkoutFlow` or `paymentFlow` [method](/sdk) on time."""

    def __init__(self, *, severity: str, message: str):

        super().__init__(severity=severity, message=message, code="init_timeout")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "InitTimeout":
        from ._schemas.responses import InitTimeoutSchema

        return InitTimeoutSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import InitTimeoutSchema

        return InitTimeoutSchema().dump(self)


class InvalidMode(Message):
    """Generated when the Application does not support the requested Checkout [mode](/../checkout/overview#complete-checkout-and-payment-only-modes)."""

    def __init__(self, *, severity: str, message: str):

        super().__init__(severity=severity, message=message, code="invalid_mode")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "InvalidMode":
        from ._schemas.responses import InvalidModeSchema

        return InvalidModeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import InvalidModeSchema

        return InvalidModeSchema().dump(self)


class BadInputData(ResponseMessage):
    """Generated when the `checkoutConfig` [object](/sdk) contains one or more invalid fields."""

    def __init__(self, *, severity: str, message: str, payload: object):

        super().__init__(
            severity=severity, message=message, payload=payload, code="invalid_fields"
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "BadInputData":
        from ._schemas.responses import BadInputDataSchema

        return BadInputDataSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import BadInputDataSchema

        return BadInputDataSchema().dump(self)


class InvalidToken(Message):
    """Generated when the `accessToken` is invalid."""

    def __init__(self, *, severity: str, message: str):

        super().__init__(severity=severity, message=message, code="invalid_token")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "InvalidToken":
        from ._schemas.responses import InvalidTokenSchema

        return InvalidTokenSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import InvalidTokenSchema

        return InvalidTokenSchema().dump(self)


class NoPaymentMethods(Message):
    """Generated when no payment method is set up for an [Application](/payment-connectors-applications#applications). Add at least one **Payment method** to the Application in the Merchant Center."""

    def __init__(self, *, severity: str, message: str):

        super().__init__(severity=severity, message=message, code="no_payment_methods")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "NoPaymentMethods":
        from ._schemas.responses import NoPaymentMethodsSchema

        return NoPaymentMethodsSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import NoPaymentMethodsSchema

        return NoPaymentMethodsSchema().dump(self)


class PaymentFailed(Message):
    """Generated when the payment fails."""

    def __init__(self, *, severity: str, message: str):

        super().__init__(severity=severity, message=message, code="payment_failed")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "PaymentFailed":
        from ._schemas.responses import PaymentFailedSchema

        return PaymentFailedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import PaymentFailedSchema

        return PaymentFailedSchema().dump(self)


class PaymentStarted(ResponseMessage):
    """Generated when the payment starts."""

    def __init__(self, *, severity: str, message: str, payload: object):

        super().__init__(
            severity=severity, message=message, payload=payload, code="payment_started"
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "PaymentStarted":
        from ._schemas.responses import PaymentStartedSchema

        return PaymentStartedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import PaymentStartedSchema

        return PaymentStartedSchema().dump(self)


class InitError(Message):
    """Generated when an error occurs during Checkout's initialization."""

    def __init__(self, *, severity: str, message: str):

        super().__init__(severity=severity, message=message, code="init_error")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "InitError":
        from ._schemas.responses import InitErrorSchema

        return InitErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import InitErrorSchema

        return InitErrorSchema().dump(self)


class PaymentConnectorError(ResponseMessage):
    """Generated when the [payment Connector](/../checkout/payment-connectors-applications#payment-connectors) triggers an error."""

    def __init__(self, *, severity: str, message: str, payload: object):

        super().__init__(
            severity=severity,
            message=message,
            payload=payload,
            code="payment_connector_error",
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "PaymentConnectorError":
        from ._schemas.responses import PaymentConnectorErrorSchema

        return PaymentConnectorErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import PaymentConnectorErrorSchema

        return PaymentConnectorErrorSchema().dump(self)


class PaymentMethodLoaded(ResponseMessage):
    """Generated when the selected payment method is loaded."""

    def __init__(self, *, severity: str, message: str, payload: object):

        super().__init__(
            severity=severity,
            message=message,
            payload=payload,
            code="payment_method_loaded",
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "PaymentMethodLoaded":
        from ._schemas.responses import PaymentMethodLoadedSchema

        return PaymentMethodLoadedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import PaymentMethodLoadedSchema

        return PaymentMethodLoadedSchema().dump(self)


class PaymentMethodLoading(ResponseMessage):
    """Generated when the selected payment method is loading."""

    def __init__(self, *, severity: str, message: str, payload: object):

        super().__init__(
            severity=severity,
            message=message,
            payload=payload,
            code="payment_method_loading",
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "PaymentMethodLoading":
        from ._schemas.responses import PaymentMethodLoadingSchema

        return PaymentMethodLoadingSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import PaymentMethodLoadingSchema

        return PaymentMethodLoadingSchema().dump(self)


class PaymentMethodLoadingError(ResponseMessage):
    """Generated when the loading of the selected payment method fails."""

    def __init__(self, *, severity: str, message: str, payload: object):

        super().__init__(
            severity=severity,
            message=message,
            payload=payload,
            code="payment_method_loading_error",
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "PaymentMethodLoadingError":
        from ._schemas.responses import PaymentMethodLoadingErrorSchema

        return PaymentMethodLoadingErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import PaymentMethodLoadingErrorSchema

        return PaymentMethodLoadingErrorSchema().dump(self)


class PaymentMethodSelected(ResponseMessage):
    """Generated when the customer selects the payment method."""

    def __init__(self, *, severity: str, message: str, payload: object):

        super().__init__(
            severity=severity,
            message=message,
            payload=payload,
            code="payment_method_selected",
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "PaymentMethodSelected":
        from ._schemas.responses import PaymentMethodSelectedSchema

        return PaymentMethodSelectedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import PaymentMethodSelectedSchema

        return PaymentMethodSelectedSchema().dump(self)


class PaymentMethodSelectionConfirmation(ResponseMessage):
    """Generated when the customer has entered the payment method information and moves to the next step."""

    def __init__(self, *, severity: str, message: str, payload: object):

        super().__init__(
            severity=severity,
            message=message,
            payload=payload,
            code="payment_method_selection_confirmation",
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "PaymentMethodSelectionConfirmation":
        from ._schemas.responses import PaymentMethodSelectionConfirmationSchema

        return PaymentMethodSelectionConfirmationSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import PaymentMethodSelectionConfirmationSchema

        return PaymentMethodSelectionConfirmationSchema().dump(self)


class PaymentMethodSelectionConfirmationFailed(ResponseMessage):
    """Generated when an error occurs when the customer selects the payment method."""

    def __init__(self, *, severity: str, message: str, payload: object):

        super().__init__(
            severity=severity,
            message=message,
            payload=payload,
            code="payment_method_selection_confirmation_failed",
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "PaymentMethodSelectionConfirmationFailed":
        from ._schemas.responses import PaymentMethodSelectionConfirmationFailedSchema

        return PaymentMethodSelectionConfirmationFailedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import PaymentMethodSelectionConfirmationFailedSchema

        return PaymentMethodSelectionConfirmationFailedSchema().dump(self)


class PaymentMethodsReceived(ResponseMessage):
    """Generated when Checkout receives and loads the payment methods configured for the Application."""

    def __init__(self, *, severity: str, message: str, payload: object):

        super().__init__(
            severity=severity,
            message=message,
            payload=payload,
            code="payment_methods_received",
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "PaymentMethodsReceived":
        from ._schemas.responses import PaymentMethodsReceivedSchema

        return PaymentMethodsReceivedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import PaymentMethodsReceivedSchema

        return PaymentMethodsReceivedSchema().dump(self)


class PaymentCancelled(Message):
    """Generated when the customer cancels the payment (for example, by closing the browser's window)."""

    def __init__(self, *, severity: str, message: str):

        super().__init__(severity=severity, message=message, code="payment_cancelled")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "PaymentCancelled":
        from ._schemas.responses import PaymentCancelledSchema

        return PaymentCancelledSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import PaymentCancelledSchema

        return PaymentCancelledSchema().dump(self)


class PaymentValidationFailed(Message):
    """Generated when Checkout and the payment service provider (PSP) do not validate the payment information entered by the customer."""

    def __init__(self, *, severity: str, message: str):

        super().__init__(
            severity=severity, message=message, code="payment_validation_failed"
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "PaymentValidationFailed":
        from ._schemas.responses import PaymentValidationFailedSchema

        return PaymentValidationFailedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import PaymentValidationFailedSchema

        return PaymentValidationFailedSchema().dump(self)


class PaymentValidationPassed(Message):
    """Generated when Checkout and the payment service provider (PSP) validate the payment information entered by the customer."""

    def __init__(self, *, severity: str, message: str):

        super().__init__(
            severity=severity, message=message, code="payment_validation_passed"
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "PaymentValidationPassed":
        from ._schemas.responses import PaymentValidationPassedSchema

        return PaymentValidationPassedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import PaymentValidationPassedSchema

        return PaymentValidationPassedSchema().dump(self)


class PaymentValidationStarted(Message):
    """Generated when the validation of the payment information entered by the customer starts."""

    def __init__(self, *, severity: str, message: str):

        super().__init__(
            severity=severity, message=message, code="payment_validation_started"
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "PaymentValidationStarted":
        from ._schemas.responses import PaymentValidationStartedSchema

        return PaymentValidationStartedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import PaymentValidationStartedSchema

        return PaymentValidationStartedSchema().dump(self)


class PaymentVerificationStarted(Message):
    """Generated when Checkout starts verifying the payment [authorization](/payments-lifecycle#authorization) given by the payment service provider (PSP)."""

    def __init__(self, *, severity: str, message: str):

        super().__init__(
            severity=severity, message=message, code="payment_verification_started"
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "PaymentVerificationStarted":
        from ._schemas.responses import PaymentVerificationStartedSchema

        return PaymentVerificationStartedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import PaymentVerificationStartedSchema

        return PaymentVerificationStartedSchema().dump(self)


class PaymentVerificationTimeout(Message):
    """Generated when the verification of the payment [authorization](/payments-lifecycle#authorization) times out."""

    def __init__(self, *, severity: str, message: str):

        super().__init__(
            severity=severity, message=message, code="payment_verification_timeout"
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "PaymentVerificationTimeout":
        from ._schemas.responses import PaymentVerificationTimeoutSchema

        return PaymentVerificationTimeoutSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import PaymentVerificationTimeoutSchema

        return PaymentVerificationTimeoutSchema().dump(self)


class ExternalTermsAndConditionsPending(Message):
    """Generated in Payment Only [mode](/../checkout/overview#complete-checkout-and-payment-only-modes) when the customer hasn't accepted the terms and conditions yet."""

    def __init__(self, *, severity: str, message: str):

        super().__init__(
            severity=severity,
            message=message,
            code="external_terms_and_conditions_pending",
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ExternalTermsAndConditionsPending":
        from ._schemas.responses import ExternalTermsAndConditionsPendingSchema

        return ExternalTermsAndConditionsPendingSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import ExternalTermsAndConditionsPendingSchema

        return ExternalTermsAndConditionsPendingSchema().dump(self)


class NoShippingMethods(ResponseMessage):
    """Generated when no [Shipping Method](/../api/projects/shippingMethods) is available for the shipping address of the [Cart](/../api/projects/carts). This may indicate an incomplete configuration."""

    def __init__(self, *, severity: str, message: str, payload: object):

        super().__init__(
            severity=severity,
            message=message,
            payload=payload,
            code="no_shipping_methods",
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "NoShippingMethods":
        from ._schemas.responses import NoShippingMethodsSchema

        return NoShippingMethodsSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import NoShippingMethodsSchema

        return NoShippingMethodsSchema().dump(self)


class OrderCreated(ResponseMessage):
    """Generated when an [Order](/../api/projects/orders) is created after a successful checkout process."""

    def __init__(self, *, severity: str, message: str, payload: object):

        super().__init__(
            severity=severity, message=message, payload=payload, code="order_created"
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderCreated":
        from ._schemas.responses import OrderCreatedSchema

        return OrderCreatedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import OrderCreatedSchema

        return OrderCreatedSchema().dump(self)


class ProjectIsDeactivated(ResponseMessage):
    """Generated when the commercetools Checkout [`projectKey`](/sdk) is deactivated and cannot be initialized. To activate it, contact the [Checkout support team](https://support.commercetools.com/)."""

    def __init__(self, *, severity: str, message: str, payload: object):

        super().__init__(
            severity=severity,
            message=message,
            payload=payload,
            code="project_deactivated",
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProjectIsDeactivated":
        from ._schemas.responses import ProjectIsDeactivatedSchema

        return ProjectIsDeactivatedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import ProjectIsDeactivatedSchema

        return ProjectIsDeactivatedSchema().dump(self)


class UnavailableLocale(ResponseMessage):
    """Generated when the provided `locale` is not [available for localization](/installing-checkout#locales). The localization falls back to English."""

    def __init__(self, *, severity: str, message: str, payload: object):

        super().__init__(
            severity=severity,
            message=message,
            payload=payload,
            code="unavailable_locale",
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "UnavailableLocale":
        from ._schemas.responses import UnavailableLocaleSchema

        return UnavailableLocaleSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import UnavailableLocaleSchema

        return UnavailableLocaleSchema().dump(self)


class DeprecatedFields(ResponseMessage):
    """Generated when the `checkoutConfig` [object](/sdk) contains one or more deprecated fields."""

    def __init__(self, *, severity: str, message: str, payload: object):

        super().__init__(
            severity=severity,
            message=message,
            payload=payload,
            code="deprecated_fields",
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "DeprecatedFields":
        from ._schemas.responses import DeprecatedFieldsSchema

        return DeprecatedFieldsSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import DeprecatedFieldsSchema

        return DeprecatedFieldsSchema().dump(self)


class OrderCreationError(ResponseMessage):
    """Generated when an [Order](/../api/projects/orders) that references an approved [Payment](/../api/projects/payments) cannot be created."""

    def __init__(self, *, severity: str, message: str, payload: object):

        super().__init__(
            severity=severity,
            message=message,
            payload=payload,
            code="order_creation_error",
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderCreationError":
        from ._schemas.responses import OrderCreationErrorSchema

        return OrderCreationErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import OrderCreationErrorSchema

        return OrderCreationErrorSchema().dump(self)


class CartWithExistingPayment(ResponseMessage):
    """Generated when trying to add a [Payment](/../api/projects/payments) to a [Cart](/../api/projects/carts) that already references an approved Payment."""

    def __init__(self, *, severity: str, message: str, payload: object):

        super().__init__(
            severity=severity,
            message=message,
            payload=payload,
            code="cart_with_exisiting_payment",
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartWithExistingPayment":
        from ._schemas.responses import CartWithExistingPaymentSchema

        return CartWithExistingPaymentSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import CartWithExistingPaymentSchema

        return CartWithExistingPaymentSchema().dump(self)


class UnsupportedCountry(ResponseMessage):
    """Generated when the country of the shipping address and/or billing address associated with the [Cart](/../api/projects/carts) does not match the countries set for the [Application](/payment-connectors-applications#applications)."""

    def __init__(self, *, severity: str, message: str, payload: object):

        super().__init__(
            severity=severity,
            message=message,
            payload=payload,
            code="unsupported_country",
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "UnsupportedCountry":
        from ._schemas.responses import UnsupportedCountrySchema

        return UnsupportedCountrySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import UnsupportedCountrySchema

        return UnsupportedCountrySchema().dump(self)
